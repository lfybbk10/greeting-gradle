# Реализация библиотеки

- Классы Book, Reader, Borrowing, LibraryManager предоставляют основную реализацию библиотеки
- Классы в пакете library.comparator предоставляют реализацию необходимых компараторов
- Присутствуют тесты для LibraryManager, компараторов и итераторов
- Демонстрация работы приложения: необходимо запустить класс LibraryDemo

____________________

# Сравнение с ArrayList

LinkedList хранит элементы как связанные узлы, а ArrayList - в массиве.
Это определяет различия в скорости и подходах к реализации:

Доступ по индексу: ArrayList - O(1), LinkedList - O(n)

Добавление/удаление с концов: LinkedList - O(1), ArrayList - O(n)

Итерация: ArrayList быстрее

## Использованные оптимизации

В rotate() применяются removeLast() / addFirst() - сдвиг за O(k) без копирования.

В partition() используется итератор вместо индексации - обход за O(n).

Избегаются subList() и get(i) - неэффективны для связного списка.

## Вывод:
ArrayList лучше для случайного доступа и частого чтения.
LinkedList эффективнее при вставках, удалениях и циклических сдвигах.

# Анализ производительности множеств

- HashSet - add=175500, HashSet - contains=86400, HashSet - remove=261800
- LinkedHashSet - add=131400, LinkedHashSet - contains=77300, LinkedHashSet - remove=194000,
 - TreeSet - add=1563300, TreeSet - contains=612700, TreeSet - remove=855100

## Выводы

HashSet — базовая и в целом самая быстрая реализация для большинства операций.
Использует хэш-таблицу, обеспечивая среднюю сложность O(1) для add, contains, remove.

LinkedHashSet — показывает сравнимую или даже немного лучшую производительность на малых объёмах данных.
Он сохраняет порядок вставки и остаётся эффективным при чтении и удалении.
Оптимальный выбор, если важен порядок элементов.

TreeSet — значительно медленнее, так как основан на сбалансированном дереве (O(log n) для операций).
Зато элементы отсортированы, что делает его подходящим, когда требуется естественный порядок или диапазонные операции (subSet, headSet, tailSet).